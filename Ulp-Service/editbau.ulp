/**
* \file editbau.ulp
* \author Jan Scholz
* \date 25.03.2015
* \brief Bauelemente bearbeiten und anlegen für die Bauteilbibliothek von Eagle 6
*/


#require 4.05
#include "Libdesy.lib"
#usage "de: <b>Desy Bauteileditor</b>\n"
"<p>Bauelemente bearbeiten und anlegen für die Bauteilbibliothek von Eagle 6"
"</p>"
"<author>Author:Jan Scholz (jan_scholz@gmx.net)</author>"
string Version = "1.6b";
// V 1.0  14.11.2014
// V 1.1  21.11.2014
// V 1.2	28.11.2014
// V 1.3	16.01.2015
// V 1.4	24.01.2015
// V 1.5  27.02.2015
// V 1.6	19.08.2015
// V 1.6a	17.03.2016
// V 1.6b	04.08.2016
//globale Variablen

// Pfad der aktuellen Eagle Bibliotheken
string LIB6_PATH = "//win.desy.de/group/sze/public/Eagle_6+/lbr"; 
string ULP_PATH = "//win.desy.de/group/sze/public/Eagle_6+/ulp/Ulp-Service";

//int's

//Flags
int VarCheck[];
int ZE_Vorzug;
int nach_PdfOrdner_fragen;
int vorheriges_Device_beibehalten;
int deleteOldDev;
int firstRun;
int obs;
int nab;
int nLib;
int nDev;
int newBib;
int newDev;
int DevAktualisieren;
int importOB;
int backtoMenu;
int error;
int hightprovided;
int emptytech;

//Zähler
int PdfNumber ;
int Anzahl_Eintraege_Pdfordner;
int counter;
int Anzahl_Librarys;
int Anzahl_Technologien_Device;
int Anzahl_Varianten;
int Anzahl_Eintraege_DatenblattSuche;


//Selections
int tableselect;
int tabletechselect[];
int tablesort;
int selected_Var_Tech;
int selected_Var_HsNrs;
int selectedVar;
int Hsselect;
int selectionVal[];
int selectionNr[];
int Attrib_automatisch_anlegen;
int pdfSelect;

//string's

//eingelesene Daten
string technologien[]; 
string OBNummern[];
string Herstellernummern[];
string Values[];
string Vorzug[];
string Hoehe[];

string vz_compare[];
string  o_compare[];
string  t_compare[];
string  h_compare[];
string  v_compare[];
string hi_compare[];


string Pdfs[];

string Pac[]; //< Packages
string Var[]; //< Varianten

string PdfPfadeELMADATA[];
string Eintraege[];
string PdfLink[];       
string HS_PDF_PATH_ELMADATA[];
string DatenblattSuche[];
string initial_HsBez;
string initial_Hs;
string initial_Devname;
string LIBS_PATHS[];
string Author_name;

string dev[];
string varianten[];
string HerstellerDaten_Orderbase;
string HerstellerDaten_Orderbase_bereits_gefunden;
string libs[];

string Bearbeiter[];
string Datierung[];
string History[];
string Kommentar[];
string userConfig[];
string DevicesetName1;
string DevicesetName2;
string HsBez;
string Hs;
string Des;
string Pdf;
string Devname;
string tags;
string oboutput;
string Prefix;
string curLibPath;

//Pfade und Konstanten
string HS_PDF_PATH;
string Pdfhref; 
string Datum;
string currentLib;
string Hs_gefunden;
string bt_gefunden;     

//Editierbare Strings für den Anwender
string Suche_Hersteller;
string SuchText;
string tech4all;
string RegexFeld;
string regex1;  
string ersetzen = "F[iI][gG][uU][rR][eE]\\s\\d{1,3}\\.\\s[^\\n]*";
string techs;
string HsNrCreator_Anfang;
string HsNrCreator_Feld1;
string HsNrCreator_Feld2;
string HsNrCreator_Feld3;
string HsNrCreator_Feld4;
string HsNrCreator_Feld5;
string HsNrCreator_Feld6;
string HsNrCreator_Ergebiss;
string neuer_Kommentar;
string newLibPath;

//Zusammenführung von Daten
string table[];
string gefundene_Herstellernummern;
string found_Bts;
string Hsvorschlag;
string PDF_PATHS[];
string PDF_NAMES[];
string Pdfsuchen;
string RegexFeldErgebnis;

//Variablen zum zwischenspeichern
string temp[];
string temp2[];
string temp_str;
string str_dev_del;


//Script das am ende per exit(cmd) an Eagle weitergegeben wird
string cmd;


//Programm

//Initialisierung

firstRun = 1;
Hsselect = 0;
nLib = 1;
nDev = 1;
newBib = 0;
newDev = 0;
DevAktualisieren = 0;
hightprovided = 0;
emptytech = 0;


//Funktionen

void debug_file(string msg) {
	status("debug_file()");
	/*if(argv[1]=="-debug" && fileglob(temp,"H:/")) {
				output("H:/debug.log","at") {   
				printf("%s",msg);
				}
		}*/
}

string Device_func(string tech,string vari) {
	return strrep(strrep(Devname,"\\*",tech,0,0),"\\?",vari,0,0);
}

/**
*	\brief Der Benutzername wird ausgelesen
*/
void readBearbeiter(){
	system("cmd.exe /c echo %USERPROFILE% > " + ULP_PATH + "/editbauData/user.ini");
	fileread(temp_str,ULP_PATH + "/editbauData/user.ini");
	int last = strsplit(userConfig,temp_str,'\\');
	if(last) Author_name = trimws(userConfig[last-1]);
	else debug("Username konnte nicht ausgelesen werden");
}

/**
*	\brief erneuert die Tabelle im ersten Tab
*/
void updateVarianten() {
	
	status("updateVarianten()");
	int Max = Anzahl_Varianten;
	for(int i = 0;i < Max; i++) {
		varianten[i] = Pac[i]+"\t"+Var[i]+"\t"
		+changeChar(technologien[i],'\n',';');
	}
}

void updatePdfPathsAndNames() {
	int t = 0;
	while(PDF_PATHS[t] != "" && PDF_NAMES[t] != "") {
		PDF_PATHS[t] = "";
		PDF_NAMES[t++] = 	"";
	}
	t = 0;
	while(Pdfs[t] != "") {
		string values[];
		strsplit(values,Pdfs[t],'\t');
		PDF_PATHS[t] = "\\\\elmadata.desy.de\\desy_WN\\Elektronik\\Artikel\\"
		+ HS_PDF_PATH + "\\"
		+ values[0];
		PDF_NAMES[t] = values[1];
		t++;
	}
}

string extractDimension(string description) {
	string z;
	if(strxstr(description,"<dimensions>") >= 0) {
		string xml = strsub(description,strxstr(description,"<dimensions>"));
		z = xmlattribute(xml, "dimensions/z","val");
	}
	return z;
}


int libExsists(string path) {
	
	for(int h = 0; h < Anzahl_Librarys ;h++) {
		if(path == LIBS_PATHS[h]) { 	
			return 1;
		}
	}
	
	return 0;
}

/**
*	\brief Die eingegebenen Daten werden nochmals einer Kotrolle unterzogen bevor das
*	Bauteil abgespeichert wird.
*/
void Check() {
	int pfad_waehlen;
	backtoMenu = 0;
	if(HsBez=="" | HsBez==" ") {
		backtoMenu = errormsg("Bitte geben Sie eine Herstellerbezeichnung an","Ok","",1);
	}
	for(int g = 0; g < Anzahl_Varianten; g++)
		if(strrchr(technologien[g],' ') > -1) { //wenn ein Leerzeichen vorhand ist..
			backtoMenu = errormsg("Bei den Technologien hat sich ein Leerzeichen "
														"eingeschlichen, bitte passen Sie die Formatierung "
														"an"
													 ,"Ok"
													 ,""
													 ,1);
		}
	if(strrchr(Devname,' ') > -1 || strrchr(Devname,';') > -1) {
		backtoMenu = errormsg("Es darf kein Leerzeichen und kein Semikolon im Namen"
													"des Devices verwendet werden.\n"
													"Bitte verwenden Sie einen anderen Namen","Ok","",1);
	}
	if(!backtoMenu) {
		if(!libExsists(curLibPath)){
			if(errormsg("Es exsistier noch keine Bibliothek für diesen Hersteller \n"
									"unter dem aktuellen Pfad in der 6er Bibliothek. \n"
									"Soll eine Bibliothek angelegt oder verknüpft werden?"
									,"Ja"
									,"Nein"
									,2)) {
				do {
					if(strlen(curLibPath) < 8)
					curLibPath = dlgFileSave("Neue Bibliothek anlegen"
																	,LIB6_PATH+"/"+Hs+".lbr");
					else
					curLibPath = dlgFileSave("Neue Bibliothek anlegen",curLibPath);
					if(curLibPath == "") {
						pfad_waehlen = errormsg("Es ist keine Bibliothek ausgewählt worden\n"
																		"Bibliothek erneut auswählen?"
																		,"Ok"
																		,"Abbrechen"
																		,2);
						backtoMenu = 1;
					}else{
						backtoMenu = 0;
						break;
					}
				}while( pfad_waehlen );	
			}	else { 
				backtoMenu = 0;
			}
		}
	}
	if(!backtoMenu) {
		if(Anzahl_Varianten) {
			if(Herstellernummern[Anzahl_Varianten-1] && Attrib_automatisch_anlegen) {
				backtoMenu = !errormsg("Sollen die Herstellernummern überschrieben werden ?","Ok","Abbrechen",2); 
			}
		} else  {
		debug("Es wurden keine Variaten für das Device gefunden, Attribute können nicht angelegt werden.");
		}
	}
	if(!backtoMenu) {
		for(int x=0;x<Anzahl_Varianten;x++) {
			if(!Attrib_automatisch_anlegen &&
					strsplit(temp, technologien[x], '\n') <
					strsplit(temp, Herstellernummern[x], '\n') ) {
				if(!errormsg("Es gibt mehr Herstellernummern als Technologien\n"
							"Daten gehen verloren, weiter machen?",
							"Ja",
							"Nein",
							2)) {
					backtoMenu = 1;
				}
			}
		}
	}
}

string getTags(string description) {
	int Anfang,Laenge;
	string return_string;
	Anfang = strxstr(description,"<tags:[^>]*",0,Laenge);
	if(Anfang < 0) return "";
	Anfang += 6;
	Laenge -= 6;
	
	sprintf(return_string,"%s",strsub(description,Anfang,Laenge));
	
	return return_string;
}

/**
*	\brief Liest den Hersteller aus der Beschreibung herraus, selbst wenn das Bauteil recht alt ist und die neuen
*	Konventionen noch nicht benutzt werden, steht die Chance recht hoch das etwas gefunden wird
*/

string ExtractHs(string Description) {
	status("ExtractHs()");
	int start1,start2,len,n;
	string t[];
	start1 = strxstr(Description,
		"</td>[\\s\\n]{1,10}<td\\s?\\w{0,8}=?\\d{0,3}\\s?>\\s{0,5}\\n\\s{0,5}&nbsp",
		0,
		len);
	start2 = strxstr(Description,
		"(\\w{1,30}[\\s-+_]?(\\s&\\s)?){0,7}\\w{1,30}",
		start1+len,
		len);
	
	deviceset(DS) {
		DS.devices(D) {
			n = strsplit(t, D.technologies, ' ');
			D.attributes(A, t[0]) {
				if(A.name == "HERSTELLER_NAME") return A.value;
			}
		}
	}
	if(start1!=-1 && strsub(Description,start2 , len )!="br") 
		return strrep(strsub(Description,start2 , len ),"&nbsp","",START,REPEAT);
	else	
		return "";
}

int maxSimilarString(string input){
	string Array1[],Array2[];
	strsplit(Array1,input,';');
	int AnzahlEintraege;
	int j = 0;
	int l = 0;
	int k = 0;
	int ende = 0;
	while(Array1[j] != "") {
		AnzahlEintraege = strsplit(temp,Array1[j],'\n');
		for(k = 0; k < AnzahlEintraege;k++) {
			Array2[l] = temp[k];
			l++;
		}
		j++;
	}
	for(k = 0; k < strlen(Array2[0]);k++) {
		for(j = 0; j < l-1; j++) {
			if(strsub(Array2[j],k,1)!=strsub(Array2[j+1],k,1)) { 
				ende = 1; 
				break;
			}
		}
		if(ende) break;
	}
	return k;
}

string ExtractHsBez(string Description) {
	status("ExtractHsBez()");
	string ListOfVal,ListOfHERSTELLER_NR,returnval;
	int start = 0;
	int len = 0;
	start = strxstr(Description,
		"td\\swidth=250.\\n&nbsp;[^\\n]*<br>\\s?\\s?\\n?&nbsp;",
		start,
		len);
	start = strxstr(Description,
		"[^\\n]*(?=<br>)",
		len+start,
		len);
	if(start>0)
		return trimws(strsub(Description,start, len ));
	
	ListOfHERSTELLER_NR = strjoin(Herstellernummern,';');
	
	ListOfVal = strjoin(Values,';');
	
	
	
	if( maxSimilarString(ListOfVal) > maxSimilarString(ListOfHERSTELLER_NR))
	returnval = strsub(Values[0],0,maxSimilarString(ListOfVal));
	else
	returnval = strsub(Herstellernummern[0],0,maxSimilarString(ListOfHERSTELLER_NR));
	if( (maxSimilarString(ListOfVal) != strlen(cutsubstring(ListOfHERSTELLER_NR,"[^\\n]*",0))) ||  
			(maxSimilarString(ListOfHERSTELLER_NR) != strlen(cutsubstring(ListOfHERSTELLER_NR,"[^\\n]*",0)))) {
		returnval += "*"; 
	} 
	//dlgMessageBox(ListOfVal);
	return returnval;
}

/**
*	\brief Der Name des Pdf-dokumentes wird aus der Beschreibung entnommen
*/
string ExtractPdf(string Description) {
	status("ExtractPdf()");
	int check = strxstr(Description,"Bautei.pdf");
	int	start = check + 10;
	int start2;
	int len = 0;
	int len2;
	string returnval;
	
	while(1) {
		start = strxstr(Description,
									  "[A-Za-z0-9\\s_.,+\\-\\*]{1,50}\\.[pP][dD][fF]",
										start+2*len+2,
										len);
		start2 = strxstr(Description,
									  ">[A-Za-z0-9\\s_.,+\\-\\*]{1,50}</a>",
										start+len,
										len2);
		if(start<0) break;
		returnval += strsub(Description,start, len )+ "\t" + strsub(Description,start2+1,len2-5) + ";";
	}
	if(returnval) {
		PdfNumber = strsplit(Pdfs, returnval, ';');
		if(!PdfNumber) Pdfs[0] = Pdf;
		if(nach_PdfOrdner_fragen) {
			string tempstr1,tempstr2;
			dlgMessageBox("Es wurde kein Pfad gefunden für die Datenblätter des Herstellers. Bitte geben Sie einen an.");
			HS_PDF_PATH = dlgDirectory("Hersteller Pdf-Ordner","\\\\elmadata.desy.de\\desy_WN\\Elektronik\\Artikel\\");
			if(HS_PDF_PATH) {
				strsplit(temp,HS_PDF_PATH,'/');
				HS_PDF_PATH = temp[6];
				for(int f=0;f<Anzahl_Eintraege_Pdfordner;f++)
					if(HS_PDF_PATH_ELMADATA[f]>HS_PDF_PATH)
						break;
				for(int g = Anzahl_Eintraege_Pdfordner - 1; g >= f; g--)
					HS_PDF_PATH_ELMADATA[g+1] = HS_PDF_PATH_ELMADATA[g];
				HS_PDF_PATH_ELMADATA[f] = Hs+";"+HS_PDF_PATH;

				debug(strjoin(HS_PDF_PATH_ELMADATA,'\n'));
			} else {
				debug("Die Pdf-Datei/en konnten nicht verlinkt werden ohne vollstaendigen Pfad");
			}
		}
		return returnval;
	} else{
		return "";
	}
}

/**
*	\brief Es wird geschaut wie oft ein Substring in einem String vorkommt
*/
int QuantityOfSubstring(string sub,string main) {
	status("QuantityOfSubstring()");
	int n=0;
	int i=0;
	int Anzahl=0;
	int emergencyExit=0;
	while(i!=-1) {	
		emergencyExit++;
		i=strstr(main,sub,n);
		n=i+strlen(sub);
		Anzahl++;
		if(emergencyExit>911) return -1;
	}
	return Anzahl;
}
/**
*	\brief Hier wird mit Hilfe von einem Regulären Ausdruck ein Text
*	nach Treffern durchsucht, die Treffer werden zurückgegeben
*/

string Filtern(string Text,string reg) {
	status("Filtern()");
	string return_Value;
	int len,start;
	if(reg == "") {
		dlgMessageBox("Hier gibts nichts zu filtern");
		return "";
	}
	while(1) {		
		start = strxstr(Text,reg, start + len,len);
		if(start==-1) break;
		return_Value += strsub(Text, start , len )+ "\n"; 
		
	}
	return return_Value;
}	

string Ersetzen(string Subject, string regex, string newString) {
	status("ersetzen()");
	string return_Value;
	int len,start,lastEnd;
	
	if(regex == "") {
		dlgMessageBox("Hier gibts nichts zu ersetzen");
		return "";
	}
	
	while(1) {	
		lastEnd = start + len;
		start = strxstr(Subject, regex, lastEnd, len);
		if(start==-1) {
			return_Value += strsub(Subject, lastEnd); 
			break;
		}
		if(start!=0) {
			return_Value += strsub(Subject, lastEnd , start-1 ); 
			return_Value += newString;
		}
	}
	return return_Value;
}	
/**
*	\brief Die Beschreibung wird ausgelesen und HTML-Tags werden entfernt
*/
string ExtractDescription(string DerString) {
	status("ExtractDescription()");
	int Anfang;
	int Ende;
	int emergencyExit=0;
	int l,i;
	if(QuantityOfSubstring("<",DerString)!=QuantityOfSubstring(">",DerString)) {
		if(!errormsg("Die Beschreibung ist nicht htmlkonform!\n"
					"Weiter machen?",
					"Ja",
					"Nein",
					2)) {
			exit(0);
		}
		debug_file("Die Beschreibung ist nicht htmlkonform!\n");
	} else {	
		deviceset(DS) {    
			Anfang = strrstr(DS.description,"<b>");
			Ende = strxstr(DerString,"</p>.{,20}<table");
			sprintf(DerString,"%s",strsub(DS.description,Anfang,Ende-Anfang));
		}
		
		while((strstr(DerString,"<")!=-1) && (strstr(DerString,">")!=-1)) {
			Anfang = strstr(DerString,"<");
			Ende = strstr(DerString,">");
			temp_str = strsub(DerString,0,Anfang);
			temp_str += strsub(DerString,Ende+1);
			DerString = temp_str;
			emergencyExit++;
			debug_file("EmergecyExit:"+int2str(emergencyExit)+
			"\nAnfang:"+int2str(Anfang)+"\nEnde:"+int2str(Ende)+"\n");
			debug_file(DerString+"\n");
			if(emergencyExit == 100) break;
			
		}
		l = strsplit(temp,DerString,'\n'); 
		
		for(i = 0; i < l;i++) {
			if(i==0) {
				Des = "<b>" + temp[i] + "</b><p>\\n";
			} else {
				Des += temp[i]+"<br>\\n";
			}
		}
		debug_file("ExtractDescription beendet\n");
	}
	DerString = changeChar(DerString,'\'','"');
	return DerString;
}		

string formatDeviceName(string Device, string techno, string var) {
	status("formatDeviceName()");
	if(strrchr(Device,'*')!=-1) {
		Device = strsub(Device,0,strrchr(Device,'*')) 
		+ techno + strsub(Device,strrchr(Device,'*') + 1);
	} else {
		Device += techno;
	}
	if(strrchr(Device,'?')!=-1) {
		Device = strsub(Device,0,strrchr(Device,'?')) 
		+ var + strsub(Device,strrchr(Device,'?') + 1);
	} else {
		Device += var;
	}
	
	return Device;
}

/**
*	\brief Es wird geschaut wer das Bauteil erstellt und bearbeitet hat	
*/
void  evaluateRevisionHistory(){
	int len;
	int lastpos;
	int aktBearbeiter,aktDatum,aktKommentar;
	int nextBearbeiter,nextDatum;
	
	deviceset(DS) {
		
		counter = 0;
		status("main() Bearbeiter und Daten");
		while(strxstr(DS.description,"\\sdurch:[^>]*(?=\\s---)",lastpos,len)>=0 ||
		strxstr(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos,len)>=0) {
			aktBearbeiter = strxstr(DS.description,"\\sdurch:[^>]*(?=\\s---)",lastpos,len);
			aktDatum = strxstr(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos,len);
			nextDatum = strxstr(DS.description,"[ia]m:[^>]*(?=\\s---)",aktDatum+10,len);
			aktKommentar = strxstr(DS.description,"//[^>]*(?=//\\s---)",lastpos,len);
			nextBearbeiter = strxstr(DS.description,"\\sdurch:[^>]*(?=\\s---)",aktBearbeiter+10,len);

			if(aktBearbeiter>=0 && aktBearbeiter < aktDatum ) {
				lastpos = strxstr(DS.description,"\\sdurch:[^>]*(?=\\s---)",lastpos,len);
				Bearbeiter[counter] = trimws(strsub(cutsubstring(DS.description,"\\sdurch:[^>]*(?=\\s---)",lastpos),8));
				lastpos = strxstr(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos,len);
				Datierung[counter] = trimws(strsub(cutsubstring(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos),3));

				if( aktKommentar >= 0 &&
						( aktKommentar < nextBearbeiter || nextBearbeiter < 0 ) &&
						( aktKommentar < nextDatum || nextDatum < 0) ) {
					lastpos = strxstr(DS.description,"//[^>]*(?=//\\s---)",lastpos,len);
					Kommentar[counter] = trimws(strsub(cutsubstring(DS.description,"//[^>]*(?=//\\s---)",lastpos),2));
				}
			} else {
				lastpos = strxstr(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos,len);
				Datierung[counter] = trimws(strsub(cutsubstring(DS.description,"[ia]m:[^>]*(?=\\s---)",lastpos),3));	
				if(strxstr(DS.description,"//[^>]*(?=//\\s---)",lastpos,len)>=0) {
					lastpos = strxstr(DS.description,"//[^>]*(?=//\\s---)",lastpos,len);
					Kommentar[counter] = trimws(strsub(cutsubstring(DS.description,"//.*(?=//\\s---)",lastpos),2));
				}
			}
			counter++;
			
			lastpos = lastpos + len;
			status("lastpos: "+int2str(lastpos)+" len: "+int2str(len));
		}
		if(counter) 
			History[0]="Ersteller\t"+Bearbeiter[0]+"\t"+Datierung[0]+"\t"+Kommentar[0];
		if(Bearbeiter[1]) History[1]="Bearbeiter";
		for(int d=1;d<counter;d++) {
			
			History[d]+="\t"+Bearbeiter[d]+"\t"+Datierung[d]+"\t"+Kommentar[d];
			
		}
		if(counter) if(Datum == Datierung[counter-1]){
			neuer_Kommentar = Kommentar[counter-1];
		}
	}
	
}
/**
*	\brief unter dem Reiter Tools kann mittels dieser Funktion schnell eine Auswahl von Herstellernummern 
*	oder Bezeichnungen erstellt werden
*/
void createHsNrs() {
	status("createHsNrs()");
	string HsNr1[],HsNr2[],HsNr3[],HsNr4[],HsNr5[],HsNr6[];
	int f1,f2,f3,f4,f5,f6;
	
	strsplit(HsNr1,HsNrCreator_Feld1,'\n');
	strsplit(HsNr2,HsNrCreator_Feld2,'\n');
	strsplit(HsNr3,HsNrCreator_Feld3,'\n');
	strsplit(HsNr4,HsNrCreator_Feld4,'\n');
	strsplit(HsNr5,HsNrCreator_Feld5,'\n');
	strsplit(HsNr6,HsNrCreator_Feld6,'\n');
	
	for(f1=0;f1<strsplit(HsNr1,HsNrCreator_Feld1,'\n');f1++) {
		if(!strsplit(HsNr2,HsNrCreator_Feld2,'\n'))
		HsNrCreator_Ergebiss += HsNrCreator_Anfang+HsNr1[f1]+ "\n";
		for(f2=0;f2<strsplit(HsNr2,HsNrCreator_Feld2,'\n');f2++) {
			if(!strsplit(HsNr3,HsNrCreator_Feld3,'\n'))
			HsNrCreator_Ergebiss+= HsNrCreator_Anfang+HsNr1[f1]+HsNr2[f2]+"\n";
			for(f3=0;f3<strsplit(HsNr3,HsNrCreator_Feld3,'\n');f3++) {
				if(!strsplit(HsNr4,HsNrCreator_Feld4,'\n'))
				HsNrCreator_Ergebiss+= HsNrCreator_Anfang+HsNr1[f1]+HsNr2[f2]+HsNr3[f3]+"\n";
				for(f4=0;f4<strsplit(HsNr4,HsNrCreator_Feld4,'\n');f4++) {
					if(!strsplit(HsNr5,HsNrCreator_Feld5,'\n'))
					HsNrCreator_Ergebiss+= HsNrCreator_Anfang+HsNr1[f1]+HsNr2[f2]+HsNr3[f3]+HsNr4[f4]+"\n";
					for(f5=0;f5<strsplit(HsNr5,HsNrCreator_Feld5,'\n');f5++) {
						if(!strsplit(HsNr6,HsNrCreator_Feld6,'\n'))
						HsNrCreator_Ergebiss+= HsNrCreator_Anfang+HsNr1[f1]+HsNr2[f2]+HsNr3[f3]+HsNr4[f4]+HsNr5[f5]+"\n";
						for(f6=0;f6<strsplit(HsNr6,HsNrCreator_Feld6,'\n');f6++) {
							HsNrCreator_Ergebiss+= HsNrCreator_Anfang+HsNr1[f1]+HsNr2[f2]+HsNr3[f3]+HsNr4[f4]+HsNr5[f5]+HsNr6[f6]+"\n";
						}
					}
				}
			}
		}
	}
}

void textFormatierung() {
	dlgDialog("Textformatierung") {
		dlgVBoxLayout{
			dlgHBoxLayout {
				dlgSpacing(10);
			}
			dlgLabel(" • \n"
			" ■ \n"
			"<sub></sub>\n"
			"<sup></sup>\n"
			"<font color=\"#F00000\"></font>\n");
			dlgPushButton("&OK") {
				dlgAccept();
			}
		}
	};
}

string einzelnePdfBearbeiten(string name_and_path) {
	string tempi[];
	string Dname,Bezeichnung_;
	string returnval;
	strsplit(tempi,name_and_path,'\t');
	Dname = tempi[0];
	Bezeichnung_ = tempi[1];
	dlgDialog("Die Pdf"){
		dlgHBoxLayout dlgSpacing(250);
		dlgGridLayout{
			dlgCell(0, 0)
				dlgLabel("Dateiname:");
			dlgCell(0, 1)	
				dlgStringEdit(Dname);
			dlgCell(1, 0)
				dlgLabel("Bezeichnung:");
			dlgCell(1, 1)	
				dlgStringEdit(Bezeichnung_);
		}
		dlgHBoxLayout{
			dlgStretch(1);
			dlgPushButton("Datei auswählen") {
				Dname = filename(dlgFileOpen("Datenblatt auswählen","\\\\elmadata.desy.de\\desy_WN\\Elektronik\\Artikel\\" + HS_PDF_PATH));
				dlgRedisplay();
			}	
			dlgStretch(1);
		}
		
		dlgHBoxLayout{
			dlgPushButton("Ok") {
				returnval = Dname + "\t" + Bezeichnung_;
				dlgAccept();
			}
			dlgPushButton("Abbrechen") {
				if(tempi[0] == "" && tempi[1] == "") {
					returnval = "";
				} else {
					returnval = tempi[0] + "\t" + tempi[1];
				}
				dlgReject();
			}
		}
		
	};
	return returnval;
}

void PdfsBearbeiten() {
	int select, Anzahl_Pdfs;
	string newPdfs[];
	for(int g=0; g < 100; g++) {
		if(Pdfs[g] != "") {
			newPdfs[g] = Pdfs[g];
		} else {
			Anzahl_Pdfs = g;
			break;
		}
	}
	
	dlgDialog("Datenblätter bearbeiten"){
			  
		dlgListView("Datei\tBezeichnung", newPdfs,select) {	
			newPdfs[select] = einzelnePdfBearbeiten(newPdfs[select]);
		}
		dlgHBoxLayout dlgSpacing(300);
		dlgHBoxLayout{
			dlgPushButton("Eintrag hinzufügen"){
				for(int k = 0; k < 100; k++) {
					if(newPdfs[k] == "") break;
				}
				newPdfs[k] = einzelnePdfBearbeiten(newPdfs[k]);
				dlgRedisplay();
			}
			dlgPushButton("Eintrag löschen"){
				newPdfs[select] = "";
				for(int h = select; h < 100; h++) {
					if(newPdfs[h+1]!="") {
						newPdfs[h] = newPdfs[h+1];
						newPdfs[h+1] = "";
					} else {
						break;
					}
				}
				dlgRedisplay();
			}
		}
		dlgHBoxLayout{
			dlgPushButton("Ok"){
				for(int g=0; g < 100; g++) {
					if(newPdfs[g] != "") {
						Pdfs[g] = newPdfs[g];
					} else {
						if(g <= Anzahl_Pdfs){
							Pdfs[g] = "";
						} else {
							break;
						}
					}
				}
				updatePdfPathsAndNames();
				dlgAccept();
			}
			dlgPushButton("Abbrechen"){
				dlgReject();
			}
		}
	};
}



int untereButtonLeiste() {
	dlgHBoxLayout {
		 
		dlgPushButton("&OK") {
			Check();
			if(!backtoMenu) {
				dlgAccept();
				return 1;
			}
		}
		dlgPushButton("&Rückgängig") { 
			dlgReset(); 
			updateVarianten();
			dlgRedisplay();
		}
		dlgPushButton("-&Cancel") { 
			dlgReject(); 
			exit (0);
		}

		dlgPushButton("&Hilfe") {
			system("cmd.exe /c \""+ ULP_PATH + "/hilfe.pdf\"");
		}
		
	}
	return 0;
}

string returnFileFromPath(string path) {
	return filename(strsub(path,0,strlen(path)-4));
}

void initVariablesAndPaths() {

	if((t2hour(time()) == 12) && ( t2minute(time()) >= 30))
			dlgMessageBox("Fleißig, fleißig. Andere machen schon Mittagspause und Du bist noch am arbeiten :D");
	int i = 0;
	Anzahl_Varianten = 0;
	Anzahl_Librarys = fileglob(LIBS_PATHS, LIB6_PATH+"/*.lbr"); 
	for(int g=1;g <= Anzahl_Librarys;g++) {
		libs[g]=returnFileFromPath(LIBS_PATHS[g-1]);
	}
	deviceset(DS) {
		Hs = ExtractHs(DS.description);
	}
	if(Hs == "") library(L) {
		Hs = returnFileFromPath(L.name);
	}
	library(L) {	
		currentLib = L.name;
		curLibPath = L.name;
		for(int h = 0; h < Anzahl_Librarys ;h++) {
			if(L.name == LIBS_PATHS[h]) { 
				Hsselect = h+1;
			}
		}
		
	}

	Anzahl_Eintraege_Pdfordner = fileread(HS_PDF_PATH_ELMADATA,ULP_PATH+"/editbauData/PdfPfade.ini");
	for(i = 0;i<Anzahl_Eintraege_Pdfordner;i++) {
		strsplit(Eintraege,HS_PDF_PATH_ELMADATA[i],';');
		if(Eintraege[0] == Hs) {
			HS_PDF_PATH = Eintraege[1];
			break;
		}
	}
	if(HS_PDF_PATH == "" && Hs != "") nach_PdfOrdner_fragen = 1;
	else nach_PdfOrdner_fragen = 0;
	
	deviceset(DS) {
		Pdf = ExtractPdf(DS.description);
		Suche_Hersteller = Hs;
		HsBez = ExtractHsBez(DS.description);
		Prefix = DS.prefix;
		initial_Hs =  Hs;
		tags = changeChar(getTags(DS.description),',','\n');
		Devname = DS.name;
		initial_Devname = Devname;        
		SuchText = DS.name;
		initial_HsBez = DS.name;
		Des = strrep(cuthtmltags(DS.description),"Ohm","Ω",0,1);
		tablesort = 3;
		if(!strlen(HsBez)) HsBez = DS.name;
		regex1 = Device_func("[\\w\\d-,\\./\\\\]{0,20}",
		"[\\w\\d-,\\./\\\\]{0,20}") + "[\\w\\d-,\\./\\\\]{0,20}";
		libs[0] = " ";
		
		DS.devices(D) {
			Anzahl_Varianten += 1;
		}
	}
}

void readDatenblattSuche() {
	Anzahl_Eintraege_DatenblattSuche = fileread(DatenblattSuche,ULP_PATH+"/editbauData/DatenblattSuche.ini");
}

/**
*	\brief Für einige Hersteller kann direkt auf der Herstellerseite nach dem Bauteil gesucht werden.
*	Der Name des Hersteller wird mit einer Auswahl von bekannten Herstellern verglichen
*	und wenn eine Übereinstimmung gefunden ist wird ein Link auf die Seite des Herstellers
*	erzeugt mit einer Suchanfrage zu dem aktuellen Bauteil
*/
string Hersteller_Suchlink(string Herstellername) {
	string temp_line[];
	for(int i = 0; i < Anzahl_Eintraege_DatenblattSuche;i++) {
		strsplit(temp_line,DatenblattSuche[i],'\t');
		if(strxstr(Herstellername,fuzzysearchrex(temp_line[0])) > -1)
			return "<a href = \"" + temp_line[1] + HsBez + temp_line[2] + "\">" + temp_line[0] + "</a>";
	}
	return "";
}

/*
*	\brief Die Beschreibung wird vor und nach dem bearbeiten von falschen
*  Zeichen befreit und unnötigen Zeilenumbrüchen bereinigt
*/

string cleanDescription(string description) {
	description = changeChar(description,'\'','"');
	if(strlen(description)==0) return description;
	while(description[strlen(description)-1] == '\n')
	description = strsub(description,0,strlen(description)-1);
	return description;
}

/**
*	\brief Vorhandene Attribute werden ausgelesen
*/
void readAttributes(){
	int i = 0;
	int k = 0;
	string t[];
	status("main() Daten einlesen");
	deviceset(DS) {
		DS.devices(D) {	
			technologien[k] = changeChar(D.technologies,' ','\n');
			Anzahl_Technologien_Device = strsplit(t, D.technologies, ' ');
			Herstellernummern[k] = "";
			OBNummern[k] = "";
			Values[k] = "";
			Vorzug[k] = "";
			for(i = 0; i<Anzahl_Technologien_Device;i++) {
				D.attributes(A, t[i]) {
					if(A.name == "HERSTELLER_NR") {
						Herstellernummern[k] += A.value;
						if(i<Anzahl_Technologien_Device-1) Herstellernummern[k] += "\n";
					}
					if(A.name == "DATENBANKOB-NR") {
						OBNummern[k] += A.value;
						if(i<Anzahl_Technologien_Device-1) OBNummern[k] += "\n";
					}
					if(A.name == "VAL") {
						Values[k] += A.value;
						if(i<Anzahl_Technologien_Device-1) Values[k] += "\n";
					}
					if(A.name == "ZE-VORZUG") {
						Vorzug[k] += A.value;
						if(i<Anzahl_Technologien_Device-1) Vorzug[k] += "\n";
					}
					if(A.name == "HEIGHT") {
						if(A.value != "")
							hi_compare[k] += A.value;
							hightprovided = 1;
					}
				}
				// Die Höhe wird direkt vom hinterlegten Package ausgelesen
				Hoehe[k] += extractDimension(D.package.description);
				if(i<Anzahl_Technologien_Device-1) Hoehe[k] += "\n";
			}
			if((strsplit(temp,Herstellernummern[k],'\n') <= Anzahl_Technologien_Device) && 
				(strsplit(temp,Values[k],'\n') <= Anzahl_Technologien_Device) && 
				(strsplit(temp,Vorzug[k],'\n') <= Anzahl_Technologien_Device))  {
					// Wenn ann ist alles gut
			} else {
				if(!(technologien[0] == "''") || (Anzahl_Technologien_Device > 0)) {
					if(!errormsg("Es sind nicht für jede Technologie alle notwendigen Attribute vorhanden \n"
											 " Möglich wäre auch das in den Datenfeldern ungleichmäßig Zeilenumbrüche \n"
											 "    vorhanden sind. Soll der Vorgang trotzdem weitergeführt werden ?    \n"
											 "                  (Daten könnten so verloren gehen)						     			  ",
											 "Ok",
											 "Abbrechen",2)) {
						exit(0);
					}
				}
			}
			
			//Packages werden unter Bezeichnung und gesetzen Namen gespeichert
			Pac[k] = D.package.name;
			Var[k] = D.name;
			k++;
		}
	}
	for(int g = 0; g < Anzahl_Varianten; g++) {		
		vz_compare[g] =            Vorzug[g];
		o_compare[g]  =         OBNummern[g];
		t_compare[g]  =      technologien[g];
		h_compare[g]  = Herstellernummern[g];
		v_compare[g]  =            Values[g];
		//hi_compare[g] =             Hoehe[g];
		
	}
	debug_file("Herstellernummern & Namen ausgelesen\n");
}

/**
*	folgend sind die einzelnen Tabs der Oberfläche in Form von Funktionen 
*/
int UebersichtTab() {
	dlgTabPage("&Übersicht") {	
		dlgHBoxLayout {   
			dlgSpacing(50);
			dlgLabel("<html><font size=4 color=#0404B4 ><b>"
			+ currentLib + "/"
			+ Devname + ".dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			+ Hs,
			1);
		}
		dlgHBoxLayout {
			dlgGroup("Author") {
				dlgHBoxLayout {   
					dlgLabel("Name :\t\t"); 
					dlgStringEdit(Author_name);
				}
			}	
			dlgGroup("Bibliothek") {
				dlgVBoxLayout{
					dlgHBoxLayout {
						dlgLabel("Pfad :\t"); 
						dlgStringEdit(curLibPath);   
						//dlgSpacing(117);
						dlgPushButton("Auswählen") {	
							curLibPath = dlgFileSave("Bibliothek", curLibPath);
							Hs = returnFileFromPath(curLibPath);
						}
					}
					dlgHBoxLayout {
						dlgLabel("Liste der 6er Bibliotheken",1);
						dlgComboBox(libs,Hsselect) {
							if(Hsselect) {
								curLibPath = LIBS_PATHS[Hsselect-1];
								Hs = libs[Hsselect];
								for(int i = 0;i<Anzahl_Eintraege_Pdfordner;i++) {
									strsplit(Eintraege,HS_PDF_PATH_ELMADATA[i],';');
									if(Eintraege[0] == Hs) HS_PDF_PATH = Eintraege[1];
								}
								nLib = 0;
							}
							else curLibPath = "";

							updateVarianten();
							dlgRedisplay();
						} 
					}
					
					
					//dlgSpacing(117);
				}
			}
		}
		dlgGroup("Bauteil") {
			dlgGridLayout {
				dlgCell(0, 0) 	dlgVBoxLayout { 
					//dlgHBoxLayout dlgSpacing(500);
					
					dlgLabel("Hersteller :\t"); 
					dlgLabel("Herstellerbez. :\t");  		
					dlgLabel("Devicename:\t"); 
					dlgLabel("Prefix :\t\t");
					dlgLabel("Datenblätt/er öffnen");
				}
				
				dlgCell(0, 1) dlgVBoxLayout {
					dlgStringEdit(Hs);  
					dlgStringEdit(HsBez); 
					dlgStringEdit(Devname); 
					dlgStringEdit(Prefix); 
					dlgComboBox(PDF_NAMES,pdfSelect) system("cmd /c \""+PDF_PATHS[pdfSelect] + "\"");
				}
				dlgCell(0, 2) dlgVBoxLayout {
					dlgHBoxLayout dlgSpacing(375);
					dlgHBoxLayout { 
						dlgSpacing(18);
						dlgVBoxLayout {
							dlgStretch(0);
							dlgCheckBox("Attribute aus Technologien und Varianten erstellen",
							Attrib_automatisch_anlegen);
							dlgCheckBox("ZE-Vorzug", ZE_Vorzug);
							//dlgCheckBox("Orderbase Daten abgleichen (noch keine Funktion)", importOB);
							dlgCheckBox("neues Bauteil aus Vorlage erstellen", vorheriges_Device_beibehalten);

							dlgHBoxLayout{
								dlgPushButton(" Pdf's bearbeiten ") {
									PdfsBearbeiten();
								}
							dlgStretch(1);
							}
						}
					}
				}                        
			}
			dlgGridLayout {
				dlgCell(0, 0)	dlgVBoxLayout { dlgHBoxLayout dlgSpacing(327);
					dlgHBoxLayout {
						dlgGroup("Beschreibung") {
							dlgTextEdit(Des); 
						}
						//dlgSpacing(32);
					}
				}
				dlgCell(0, 1)	dlgVBoxLayout {
					
					dlgHBoxLayout {
						dlgGroup("Tags") {
							dlgTextEdit(tags);
						}
						dlgGroup("Suche") {
							dlgVBoxLayout {
								dlgLabel(Pdfsuchen,1);
								dlgLabel("<a href = \"https://www.google.de/search?q="
								+ HsBez + "+"
								+ cutsubstring(Hs,"[^\\s]+(\\s[^\\s]{4,20})?",0)+"+filetype:pdf\">Google</a>");
								dlgLabel("<a href = \"http://de.rs-online.com/web/c/?searchTerm="
								+ HsBez + "\">RS</a>",1);
								dlgLabel("<a href = \"http://de.farnell.com/jsp/search/browse.jsp;"
								"jsessionid=NWD0MG31BTVE2CQLCIRJKBQ?N=0&Ntk=gensearch&Ntt="
								+ HsBez + "\">Farnell</a>",1);
							}
						}
					} 
				}
				
				dlgDialog("Version") {
					dlgLabel(" DESY Bauteil-Editor\n\n Version "+Version);
					dlgPushButton("+&ok") dlgAccept();
				};
				
				dlgCell(1, 0) dlgHBoxLayout {
					dlgGroup("Revisions-Historie") {
						int sel;
						int sorting= -1;
						dlgHBoxLayout dlgSpacing(0);
						dlgListView("\t Name\tDatum\tKommentar",History,sel,sorting) {
							strsplit(temp,History[sel],'\t');
							dlgDialog("History") {
								dlgHBoxLayout {
									dlgGroup(temp[0]) {
										dlgVBoxLayout {
											
											dlgStringEdit(temp[1]);
											dlgStringEdit(temp[2]);
											dlgStretch(1);
										}
										dlgTextEdit(temp[3]);
									}
								}
								dlgHBoxLayout {
									dlgPushButton("+&Ok") {
										dlgAccept();
										History[sel] = temp[0]+"\t"+temp[1]+"\t"+temp[2]+"\t"+temp[3];
										Bearbeiter[sel]= temp[1];
										Datierung[sel]= temp[2];
										Kommentar[sel]=temp[3];
									}
									dlgPushButton("-&Abbrechen") {dlgReject();}
									dlgPushButton("&loeschen") {
										dlgAccept();
										if(counter) {
											for(int var = sel ; var < counter ; var++) {
												History[var] = History[var+1];
												History[var+1] = "";
												Bearbeiter[var] = Bearbeiter[var+1];
												Bearbeiter[var+1] = "";
												Datierung[var] = Datierung[var+1];
												Datierung[var+1] = "";
												Kommentar[var] = Kommentar[var+1];
												Kommentar[var+1] = "";
											}
											counter--;
										} else {
											dlgMessageBox("kein Eintrag mehr vorhanden");
										}
									}
								}
							};
							updateVarianten();
							dlgRedisplay();
						}
					}
					//dlgSpacing(32);
				}
				
				dlgCell(1, 1) dlgVBoxLayout {
					dlgGroup("Kommentar") {
						dlgTextEdit(neuer_Kommentar);
					}
				}
			}		
		}
		if(untereButtonLeiste()) return 1;
	}
	return 0;
}
int DatenTabs() {
	int x1,x2,VarNrRest,Numbers[];
	for(int y = 0 ; y < Anzahl_Varianten ; y++ ) {
		Numbers[y]=y;
	}

	x1 = 0;
	x2 = 0;
	
	int Tabs = Anzahl_Varianten/3;
	if(Anzahl_Varianten%3) Tabs++;
	for(x1; x1 < Tabs;x1++) {
		dlgTabPage("&Daten "+int2str(1+x1)) {	
			dlgHBoxLayout {   
				dlgSpacing(50);
				dlgLabel("<html><font size=4 color=#0404B4 ><b>"
				+ currentLib +"/"
				+ Devname + ".dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
				"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
				+Hs);
			}
			
			dlgHBoxLayout dlgSpacing(700);
			
			dlgHBoxLayout { 
				
				
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {		
						dlgLabel("<html><b><font size=3 color=#FF0000 >" + Var[x1*3+x2]);
					}
				}
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Technologie");
						dlgTextEdit(technologien[x1*3+x2]);
						//dlgLabel(int2str(strsplit(temp,technologien[x1*3+x2],'\n'))+" Eintraege");
					}
				}
				
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Orderbase Nummer");
						dlgSpacing(0);
						dlgTextEdit(OBNummern[x1*3+x2]);
						//dlgLabel(int2str(strsplit(temp,OBNummern[x1*3+x2],'\n'))+" Eintraege");
					}
				}
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Herstellernummer");
						dlgSpacing(0);
						dlgTextEdit(Herstellernummern[x1*3+x2]); 
						//dlgLabel(int2str(strsplit(temp,Herstellernummern[x1*3+x2],'\n'))+" Eintraege");
					}
				}
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Bezeichnung (Value)");
						dlgSpacing(0);
						dlgTextEdit(Values[x1*3+x2]); 
						//dlgLabel(int2str(strsplit(temp,Values[x1*3+x2],'\n'))+" Eintraege");
					}
				}
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Hoehe");
						dlgTextEdit(Hoehe[x1*3+x2]); 
						//dlgLabel(int2str(strsplit(temp,Vorzug[x1*3+x2],'\n'))+" Eintraege");
					}
					
				}
				dlgVBoxLayout{
					for(x2=0; x2 < 3 & x2 < Anzahl_Varianten-x1*3;x2++) {
						if(!x2%2)dlgLabel("<html><b><font size=3 color=#0B0B61 >Ze-Vorzug");
						dlgTextEdit(Vorzug[x1*3+x2]); 
						//dlgLabel(int2str(strsplit(temp,Vorzug[x1*3+x2],'\n'))+" Eintraege");
					}
					
				}	
			}
			if(untereButtonLeiste()) return 1;
		}
	}
	return 0;
}

int ToolsTab(){
	dlgTabPage("&Tools") {
		dlgGroup("Regex Suche für Bauteilnummern in Datenblaettern") {
			dlgGridLayout{
				dlgCell(0,0) dlgVBoxLayout{
					dlgHBoxLayout {dlgSpacing(500);}
					dlgTextEdit(RegexFeld);
				}
				dlgCell(0,1) dlgTextView(RegexFeldErgebnis);
				dlgCell(1,0) dlgHBoxLayout {
					dlgLabel("Regulärer Ausdruck:");
					dlgStringEdit(regex1);
					
				}
				dlgCell(1,1) dlgHBoxLayout {
					dlgPushButton("&filtern") {
						RegexFeldErgebnis = Filtern(RegexFeld,regex1);
						dlgRedisplay();
					} 

				}
				dlgCell(2,0) dlgHBoxLayout {
					dlgLabel("Ersetzen durch:");
					dlgStringEdit(ersetzen);
				}
				dlgCell(2,1) dlgHBoxLayout {
					dlgPushButton("&ersetzen") {
						RegexFeldErgebnis = strrep(RegexFeld,regex1,ersetzen,0,1);
						dlgRedisplay();
					} 
				}
			}
		}
		dlgGroup("Herstellernummern Generator") {
			dlgHBoxLayout{
				dlgStringEdit(HsNrCreator_Anfang);
				dlgTextEdit(HsNrCreator_Feld1);
				dlgTextEdit(HsNrCreator_Feld2);
				dlgTextEdit(HsNrCreator_Feld3);
				dlgTextEdit(HsNrCreator_Feld4);
				dlgTextEdit(HsNrCreator_Feld5);
				dlgTextEdit(HsNrCreator_Feld6);
			}
			dlgPushButton("&erstellen") { 
				createHsNrs();
				updateVarianten();
				dlgRedisplay();
			}
			dlgTextEdit(HsNrCreator_Ergebiss);
		}
		if(untereButtonLeiste()) return 1;	
	}
	return 0;
}

int OrderbaseTab() {

	dlgTabPage("Manuelle Orderbase-Suche") {
		int Zeilen,zeile = 0;	
		dlgHBoxLayout {   
			dlgSpacing(50);
			dlgLabel("<html><font size=4 color=#0404B4 ><b>"
			+ currentLib + "/"
			+ Devname + ".dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"+Hs);
		}
		
		dlgGridLayout {
			dlgCell(0, 0) dlgLabel("Bauteilname: ");
			dlgCell(0, 1) dlgStringEdit(SuchText);
			dlgCell(1, 0) dlgLabel("Hersteller: ");
			dlgCell(1, 1) dlgStringEdit(Suche_Hersteller);
			dlgCell(1, 2) dlgPushButton("+&Suchen") { 
				//btsearch();
				error = system("cmd.exe /c sqlcmd -S zitleitsql3 -d orderbase_ze -Q "
				"\"select nr, name, hersteller_artikelnr, beschreibung "
				"from artikel_unarchiviert where name like '"
				+ changeChar(Suche_Hersteller,'*','%') +"%' and hersteller_artikelnr like '"
				+ changeChar(SuchText,'*','%')+"%';\"  -s\"$\" > "+ULP_PATH+"/orderbase.txt");
				if(error) 
					if(errormsg("SQL-Abfragen können nur getätigt werden wenn Microsoft® SQL Server® 2014 installiert ist\nSoll die Software installiert werden?","Ja","Nein",2)) {
						error = system("cmd.exe /c " + ULP_PATH + "/SQLEXPR_x86_ENU/setup.exe");
						if(error) errormsg("Es ist ein Fehler bei der Installation aufgetreten","Ok","",1);
					}
				fileread(oboutput,ULP_PATH+"/orderbase.txt");
				//strrep(oboutput,"\\s{,20}",";",0,1);
				oboutput = changeChar(oboutput,'$','\t');
				for(int f;f < Zeilen-4;f++) {
					table[f] = "";
				}
				Zeilen = strsplit(temp,oboutput,'\n');
				//debug(int2str(Zeilen));
				zeile = 0;
				for(zeile;zeile < Zeilen-4;zeile++) {
					table[zeile] = " \t"+temp[zeile+2];
				}
				dlgRedisplay();
			}
		}
		//dlgLabel(oboutput,1);
		dlgListView("gewählt\t"
		"OrderbaseNr\t"
		"Herstellername\t"
		"Herstellerartikelnr\t"
		"Beschreibung",
		table,
		tableselect,tablesort) { 
			
			if(tabletechselect[tableselect]==Anzahl_Varianten) {
				tabletechselect[tableselect] = 0;
				temp_str = "";
			} else {
				temp_str = Var[tabletechselect[tableselect]];
				tabletechselect[tableselect]++;
			}
			table[tableselect] = temp_str+strsub(table[tableselect],strstr(table[tableselect],"\t"));	
		}
		dlgPushButton("Bauteile anlegen") { 
			int eintraege=0,k=0;
			string tmptable[];
			
			for(zeile = 0; zeile < Zeilen-4; zeile++) {	
				strsplit(temp,table[zeile],'\t');
				for(k=0;k<Anzahl_Varianten;k++) {
					if(temp[0] == Var[k]) {
						tmptable[eintraege] = changeChar(table[zeile],'\t',' ');
						OBNummern[k] += "\n"+trimws(temp[1]);
						Vorzug[k] += "\n"+"nein";
						Herstellernummern[k] += "\n"+trimws(temp[3]);	
						eintraege++;
						technologien[k] += "\n"+int2str(eintraege);
						Values[k] += "\n"+trimws(temp[3]);
					}
				}
			}	

		}

		if(untereButtonLeiste()) return 1;
	}
	return 0;
}

/**
*	\brief Benutzeroberfläche
*/
int menue() {
	status("menue()");
	
	int k;
	string HsNrOpt[]={"Tech & Variante wie Devname","hinterlegte Daten"};
	nLib = 1;
	nDev = 1;
	
	updateVarianten();
	readDatenblattSuche();
	Pdfsuchen = Hersteller_Suchlink(Hs);
	
	dlgDialog("DESY Bauteil Editor \t\t Version "+Version) {
		dlgTabWidget {
			
			UebersichtTab();
			
			DatenTabs();
			
			ToolsTab();
			
			OrderbaseTab();
			
		}
	};
	return 0;
}

/**
*	\brief Hauptprogramm
*/
void main() {
	status("main() start");
	
	sprintf(Datum,"%d.%d.%d",t2day(time()),t2month(time())+1,t2year(time()));
	
	if (library && deviceset) {
			library(L){
			//if(L.deviceset.activedevice.library != "") {
				//debug_file("debug Log vom "+Datum+"\n");
				int laenge;
				
				string att[]={"DATENBANKOB-NR",
											"HERSTELLER_NAME",
											"HERSTELLER_NR",
											"VAL",
											"ZE-VORZUG",
											"HEIGHT"};
				string value;
				string Vari;
				string tech;
				
				deviceset(DS) {

					initVariablesAndPaths();
				
					readAttributes();
					
					evaluateRevisionHistory();
					
					readBearbeiter();
					
					updatePdfPathsAndNames();

					if(DS.prefix=="IC") cmd +="PREFIX U;";
					
					// DS.gates(G) {
						// if(G.name == "G$1") cmd +="NAME G$1 G;";
					// }
					
					Des = cleanDescription(Des);

					if(!menue()) exit(0);
					
					Des = cleanDescription(Des);
					
					libs[0] = "";
					
					int zeilen = strsplit(temp,Des,'\n'); 
					
					for(int l = 0; l < zeilen;l++) {
						if(l==0) {
							Des = "<b>" + temp[l] + "</b><p>\\n";
						} else {
							Des += temp[l]+"<br>\\n";
						}
					}
					
					cmd += "Prefix "+Prefix+";";
					
					
					if(vorheriges_Device_beibehalten) {
						if(DS.name!=Devname) {
							cmd += "WRITE;";
							cmd += "OPEN '"+curLibPath+"';";
							cmd += "COPY '"+DS.name+".dev@"+L.name+"' '"+Devname+"';"; 
							cmd += "EDIT '"+Devname+".dev';"; 
						} else {
							if(L.name != curLibPath) {
								cmd += "WRITE;";
								cmd += "OPEN '"+curLibPath+"';";
								cmd += "COPY '"+DS.name+".dev@"+L.name+"' '"+Devname+"';"; 
								cmd += "EDIT '"+Devname+".dev';"; 	
							} else {
								Devname = dlgStrEd("Achtung","Das Device benötigt einen anderen Namen",Devname);
								cmd += "WRITE;";
								cmd += "COPY '"+DS.name+".dev@"+L.name+"' '"+Devname+"';"; 
								cmd += "EDIT '"+Devname+".dev';"; 	
							}
						}
					} else { 
						if(curLibPath != L.name) {
							cmd += "WRITE;";
							cmd += "OPEN '"+curLibPath+"';";
							cmd += "COPY '"+DS.name+".dev@"+L.name+"';";
							cmd += "WRITE;";
							cmd += "OPEN '"+L.name+"';";
							cmd += "REMOVE '"+DS.name+".dev';";
							cmd += "WRITE;";
							cmd += "OPEN '"+curLibPath+"';";
							cmd += "EDIT '"+DS.name+".dev';"; 
						} 
						if(initial_Devname != Devname) {
							cmd += "rename '"+ DS.name + "' '" + Devname + "';";
						}
						
					}

					string  o[]; 
					string vz[];
					string  t[];
					string  h[];
					string  v[];
					string hi[];
					
					DS.devices(D) {
				/**
				*	Vergleich der Ursprünglichen Attribute mit den aktuellen.
				*	Wenn Veränderungen statt gefunden haben oder die Attribute
				* automatisch angelegt werden sollen wird das notwendige 
				* Script erstellt.
				*/
						for(int g = 0; g < Anzahl_Varianten; g++) {
							if( (cmpstr(vz_compare[g],            Vorzug[g]) != 0) ||	
									(cmpstr( o_compare[g],         OBNummern[g]) != 0) ||
									(cmpstr( t_compare[g],      technologien[g]) != 0) ||
									(cmpstr( h_compare[g], Herstellernummern[g]) != 0) ||
									(cmpstr( hi_compare[g],            Hoehe[g]) != 0) ||
									(cmpstr( v_compare[g],            Values[g]) != 0) ||
									(Attrib_automatisch_anlegen == 1) ||
									!hightprovided)
									{
								
								strsplit(vz,           		 Vorzug[g], '\n');
								strsplit( h, 	  Herstellernummern[g], '\n');
								strsplit( v,               Values[g], '\n');
								strsplit( o,            OBNummern[g], '\n');
								strsplit(hi,            Hoehe[g], '\n');
								
								int AnzahlTechnologien = strsplit(t,   technologien[g], '\n');
								
								if(Var[g]=="''") Vari="";
								else Vari = Var[g];

								cmd +="Package '"+ Vari + "';";	
								cmd += "TECHNOLOGY -*;";
								
								for (int k = 0; k <= 5; k++) {
									for (int i = 0; i < AnzahlTechnologien; i++) {
										if(strxstr(t[i],"'")<0) tech = t[i];
										else tech = "";
										switch(k) {
										case 0: switch (Attrib_automatisch_anlegen) {
											case 0:	value=o[i]; break;  //Orderbase-Nr
											default:	value=""; break;
											} break;
										case 1:	value=Hs; break;	//Hersteller
										case 2: switch (Attrib_automatisch_anlegen) {	 //HerstellerNr					
											case 0:	if(h[i]=="" || h[i]== " ") {
													value=formatDeviceName(HsBez,"",Vari);
												} else {
													value=h[i]; 
												}
												break;
											case 1:	value=formatDeviceName(HsBez,tech,Vari);	break;
											} break;
										case 3:	switch (Attrib_automatisch_anlegen) { //VAL
											case 0:	if(v[i]=="" || v[i]== " ") {
													value=formatDeviceName(HsBez,tech,Vari);
												} else {
													value=v[i]; 
												}
												break;
											case 1:	value=formatDeviceName(HsBez,tech,Vari);	break;	
											} break;
										case 4: if(ZE_Vorzug)  {  // ZE-Vorzug
												value="ja";
											} else {
												if(vz[i]=="") value = "nein";
												else value=vz[i]; 
											} break;
										case 5: switch (Attrib_automatisch_anlegen) {
											case 0:	value = hi[i]; break;  //Hoehe
											default:	value="1.0"; break;
											} break;
										}	
										
										if( t[i] == "'"  ||
											  t[i] == "''" ||
											  t[i] == ""   ) {
												cmd += "TECHNOLOGY ''";	
												emptytech = 1;
										} else cmd += "TECHNOLOGY '"+t[i]+"'";

										cmd +=";  ATTRIBUTE "+att[k]+" '"+value+"' constant;\n";
									}
								}
							}
							if(!emptytech) cmd += "TECHNOLOGY -'';\n";
						}
					}
					
					cmd += "DESCRIPTION '<html> \\n" + Des +
					"</p> \\n"
					"<qt> \\n"
					"<table border=2> \\n"
					"<tr> \\n"
					"<td width=100> \\n"
					"&nbsp; Hersteller:  <br>  \\n"
					"&nbsp; Herstellerbez:  <br>  \\n"
					"&nbsp; Datenblatt : \\n"
					"</td>  \\n"
					"\\n"
					"<td width=250>\\n"
					"&nbsp; "+Hs+"<br>  \\n"
					"&nbsp; " +HsBez+ " <br>  \\n";
					for(int idx = PdfNumber; idx >= 0; idx--) {
						if(Pdfs[idx] != "") {
							//debug(PDF_PATHS[idx]);
							string path_name[];
							strsplit(path_name,Pdfs[idx],'\t');
							cmd+= "&nbsp; <a href = \"file:"
										+ PDF_PATHS[idx] + "\">"
										+ PDF_NAMES[idx] +"</a>";	
							if(idx > 0) cmd += "<br>";
							cmd += "\\n";
						}
					}
					string vorheriger_Bearbeiter;
					cmd += "</td>\\n</tr>\\n</table>\\n";
					Bearbeiter[counter]= Author_name;
					Datierung[counter]= Datum;
					Kommentar[counter]=neuer_Kommentar;
					if(counter>0)
					if(Datum == Datierung[counter-1]) Kommentar[counter-1]=neuer_Kommentar;

					for(int k=0;k<=counter;k++) {
						if(!k) cmd += "<!--- Erstellt ";
						else cmd += "<!--- Geändert ";
						cmd += "durch: "+Bearbeiter[k]+" --->\\n<!---\t\t\t\tam: "+Datierung[k]+" --->\\n";
						if(Kommentar[k]!="") cmd += "<!---\t// "+Kommentar[k]+" // --->\\n";
						if(Bearbeiter[k]!="" && k) vorheriger_Bearbeiter = Bearbeiter[k];
						if(Datierung[k]==Datum) break;
					}
					cmd += "</qt>\\n</html>\\n<tags:"+changeChar(tags,'\n',',')+">\\n';";
				}
				
			}
			if(fileglob(temp,"C:/Users/Scholzj/Desktop/")) output("C:/Users/Scholzj/Desktop/debug.txt", "wt") { 
				printf("%s",cmd); 
			}
			if(fileglob(temp,ULP_PATH+"/editbauData/PdfPfade.ini")) {
				output(ULP_PATH+"/editbauData/PdfPfade.ini","wt") {
					temp_str = strjoin(HS_PDF_PATH_ELMADATA,'\n');
					printf("%s",strsub(temp_str,0,strlen(temp_str)-1));
				}
			} else {
				debug(ULP_PATH+"/editbauData/PdfPfade.ini nicht gefunden und wird neu angelegt");
				output(ULP_PATH+"/editbauData/PdfPfade.ini","wt") {
					temp_str = strjoin(HS_PDF_PATH_ELMADATA,'\n');
					printf("%s",strsub(temp_str,0,strlen(temp_str)-1));
				}
			}
			exit(cmd);
		
		
	} else {
		dlgMessageBox(":Diese Ulp muss in einer Bibliothek gestartet werden, mit einem geöffneten Device ");
	}
	exit (0);
}
